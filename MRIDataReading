#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <ctime>
#include <iomanip>
#include <unistd.h>
#include <curl/curl.h>
#include <mqtt/async_client.h>

// --- Configuration ---
const std::string FTP_HOST = "10.1.10.132";
const std::string FTP_USER = "MMService";
const std::string FTP_PASS = "MagnetMonitor";
const std::string LOCAL_FILE = "/tmp/latest_data.dat";

const std::string MQTT_SERVER = "tcp://broker.emqx.io:1883";
const std::string MQTT_CLIENT_ID = "OpenWrt_MagnetMonitor";
const std::string MQTT_TOPIC = "magnet_monitor/data";
const std::string MQTT_USER = "emqx";
const std::string MQTT_PASS = "public";

const int POLL_INTERVAL = 300;  // 5 Minutes
const int RETRY_INTERVAL = 120; // 2 Minutes

// Function to generate the daily filename (dayDDMMYY.dat)
std::string get_remote_filename() {
    std::time_t t = std::time(nullptr);
    std::tm* now = std::localtime(&t);
    std::ostringstream oss;
    oss << "/CFDisk/mindata/day" 
        << std::setfill('0') << std::setw(2) << now->tm_mday
        << std::setfill('0') << std::setw(2) << (now->tm_mon + 1)
        << std::setfill('0') << std::setw(2) << (now->tm_year % 100)
        << ".dat";
    return oss.str();
}

// Callback for CURL to write data to file
size_t write_data(void* ptr, size_t size, size_t nmemb, FILE* stream) {
    return fwrite(ptr, size, nmemb, stream);
}

// Perform FTP Download
bool download_ftp() {
    CURL* curl;
    CURLcode res;
    bool success = false;
    std::string url = "ftp://" + FTP_HOST + get_remote_filename();

    curl = curl_easy_init();
    if (curl) {
        FILE* fp = fopen((LOCAL_FILE + ".tmp").c_str(), "wb");
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_USERNAME, FTP_USER.c_str());
        curl_easy_setopt(curl, CURLOPT_PASSWORD, FTP_PASS.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
        curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);

        res = curl_easy_perform(curl);
        fclose(fp);

        if (res == CURLE_OK) {
            std::rename((LOCAL_FILE + ".tmp").c_str(), LOCAL_FILE.c_str());
            success = true;
        } else {
            std::cerr << "FTP Download Failed: " << curl_easy_strerror(res) << std::endl;
        }
        curl_easy_cleanup(curl);
    }
    return success;
}

// Parse latest row from file
std::string get_latest_row() {
    std::ifstream file(LOCAL_FILE);
    std::string line, last_line;
    if (file.is_open()) {
        while (std::getline(file, line)) {
            if (!line.empty()) last_line = line;
        }
        file.close();
    }
    return last_line;
}

// Send data to MQTT
void send_mqtt(const std::string& payload) {
    if (payload.empty()) return;

    mqtt::async_client client(MQTT_SERVER, MQTT_CLIENT_ID);
    mqtt::connect_options connOpts;
    connOpts.set_user_name(MQTT_USER);
    connOpts.set_password(MQTT_PASS);
    connOpts.set_clean_session(true);

    try {
        client.connect(connOpts)->wait();
        client.publish(MQTT_TOPIC, payload, 1, false)->wait();
        client.disconnect()->wait();
        std::cout << "Data sent to cloud successfully." << std::endl;
    } catch (const mqtt::exception& exc) {
        std::cerr << "MQTT Error: " << exc.what() << std::endl;
    }
}

int main() {
    std::cout << "Starting C++ Magnet Monitor Service..." << std::endl;
    
    while (true) {
        if (download_ftp()) {
            std::string latest_row = get_latest_row();
            send_mqtt(latest_row);
            sleep(POLL_INTERVAL);
        } else {
            std::cout << "Retrying FTP in 2 minutes..." << std::endl;
            sleep(RETRY_INTERVAL);
        }
    }
    return 0;
}